# Стековые вычисления на языке C

### Задачи

1. Пройти это руководство, чтобы разобраться со стековой машиной.
2. Соединить полученные навыки с [примером калькулятора](calculator.md)
3. Переписать калькулятор, чтобы он генерировал код для данной стековой машины (то есть писал в файл output.c код на языке C, вычисляющий конкретное арифметическое выражение, переданное калькулятору)

### Принцип стековых вычислений

Стековые виртуальные машины &mdash; самые распространённые. Например, виртуальные машины CLR и JVM являются стековыми. Это значит, что любой компилятор под платформу JVM (включая компиляторы Java, Groovy, Kotlin, Scala и других языков) должен генерировать код, использующий стековую машину для вычисления выражений.

Все современные ассемблеры и промежуточные языки компиляторов содержат понятие "стек", и на них можно писать код в стиле стековой машины. Условно, это выглядит так:

```vb
push 8
push -2
push 17
add
sub
```

1. После первых трёх команд стек будет содержать три значения: [8, -2, 17].
2. После команды add последние два числа на стеке будут сложены, результат будет положен в предпоследнюю ячейку, а затем последняя ячейка будет выкинута. В итоге стек будет содержать [8, 15].
3. После команды sub из предпоследнего числа на стеке будет вычтено последнее, результат попадёт в предпоследнюю ячейку, а затем последняя ячейка будет выкинута. В итоге стек будет содержать [-7].

Таким образом, мы вычислили выражение `8 - (-2 + 17) = -7`.

### Представление стека

Написать минимальную программу для стековых вычислений очень легко.

1. Объявим массив для хранения данных стека и переменную для хранения индекса вершины
2. Объявим функции push, pop, add и т.д.
3. Не забудьте определить переменные в файле `stackvm.cpp`.

##### stackvm.h
```cpp
#pragma once

static const int STACK_SIZE = 1000;
extern int g_stackVM[STACK_SIZE];
extern int g_stackVMTop;

void push(int value);
void pop();
void add();
void multiply();
void substract();
void divide();
```

Нам пригодится также функция printStack, печатающая содержимое стека:
```cpp
void printStack()
{
    puts("--- stack begin ---");
    for (int i = 0, n = g_stackVMTop; i <= n; ++i)
    {
        const int value = g_stackVM[i];
        printf("%d. %d\n", i, value);
    }
    puts("--- stack end ---");
}
```

### Опасные места

При работе со стеком есть две опасных ситуации:

- переполнение стека (stack overflow)
- уход ниже стека (stack underflow)

Если при исполнении программы на микропроцессоре возникнет stack overflow или stack underflow для стека потока ОС, то, скорее всего, ОС убьёт весь провинившийся процесс со всеми потоками. В нашем стеке мы будем проверять stack underflow, и в случае проблем вызывать стандартную функцию `abort();`:

##### добавить в stackvm.cpp
```cpp
static void check_underflow(int reserve)
{
    if (g_stackVMTop < reserve)
    {
        fprintf(stderr, "stack underflow\n");
        abort();
    }
}
```

### Push и pop

1. Функция push должна получать целое число, которое следует положить на стек
2. Функция pop не имеет аргументов, зато проверяет stack underflow
3. Функции для арифметических операций также проверяют stack underflow, т.к. два операнда они берут из стека.

##### добавить в stackvm.cpp
```cpp
void push(int value)
{
    g_stackVM[++g_stackVMTop] = value;
}

void pop()
{
    check_underflow(0);
    --g_stackVMTop;
}

void add()
{
    check_underflow(1);
    g_stackVM[g_stackVMTop - 1] = g_stackVM[g_stackVMTop - 1] + g_stackVM[g_stackVMTop];
    --g_stackVMTop;
}

void multiply()
{
    check_underflow(1);
    g_stackVM[g_stackVMTop - 1] = g_stackVM[g_stackVMTop - 1] * g_stackVM[g_stackVMTop];
    --g_stackVMTop;
}

void substract()
{
    check_underflow(1);
    g_stackVM[g_stackVMTop - 1] = g_stackVM[g_stackVMTop - 1] - g_stackVM[g_stackVMTop];
    --g_stackVMTop;
}

void divide()
{
    check_underflow(1);
    g_stackVM[g_stackVMTop - 1] = g_stackVM[g_stackVMTop - 1] / g_stackVM[g_stackVMTop];
    --g_stackVMTop;
}
```

### Используем стек

Вот пример кода, использующего написанную нами стековую машину для вычислений:
##### main.cpp
```cpp
#include <stack.h>

int main(int , char *[])
{
    // natural notation: 7 + 13 / 3 * 10
    // reverse polish notation: 7, 13, 3, /, 10, *, +
    // expected result: 47

    push(7);
    push(13);
    push(3);
    divide();
    push(10);
    multiply();
    add();

    printStack();

    return 0;
}
```
##### вывод
```
--- stack begin ---
0. 47
--- stack end ---
```

Из комментариев в примере легко понять заметить, как произвольную формулу превратить в код для стековой машины

1. берём выражение, например `7 + 13 / 3 * 10`
2. переписываем его в обратной польской нотации `7 13 3 / 10 * +`
3. транслируем каждое число в команду `push N`, а каждый оператор - в соответствующую вычисляющую команду
4. в конце вызываем `printStack` для печати стека

### К чему это всё?

Принцип стековых вычислений &mdash; это самый простой способ сделать генерацию кода выражений в компиляторе. При этом скорость работы стековой достаточно хороша, хотя и не оптимальна. Виртуальные машины CLR (.NET) и JVM (Java) требуют обязательного использования стековых вычислений, реальные микропроцессоры ради скорости позволяют использовать регистры. Альтернативные способы генерации кода:

- сложнее, чем стековый: генерировать промежуточный код в SSA-форме, обычно на языке LLVM-IR для дальнейшей компиляции через утилиту `llc` или компилятор `clang`.
- самый сложный: генерировать код для регистровой машины, обычно в форме ассемблера реального процессора

### Читать далее

- [Обратная польская запись (ru.wikipedia.org)](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C)
